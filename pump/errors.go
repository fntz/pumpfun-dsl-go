// Code generated by https://github.com/gagliardetto/anchor-go. DO NOT EDIT.

package pump

import (
	"encoding/json"
	"errors"
	"fmt"
	ag_jsonrpc "github.com/gagliardetto/solana-go/rpc/jsonrpc"
)

var (
	_ *json.Encoder        = nil
	_ *ag_jsonrpc.RPCError = nil
	_ fmt.Formatter        = nil
	_                      = errors.ErrUnsupported
)
var (
	ErrNotAuthorized = &customErrorDef{
		code: 6000,
		msg:  "The given account is not authorized to execute this instruction.",
		name: "NotAuthorized",
	}
	ErrAlreadyInitialized = &customErrorDef{
		code: 6001,
		msg:  "The program is already initialized.",
		name: "AlreadyInitialized",
	}
	ErrTooMuchSolRequired = &customErrorDef{
		code: 6002,
		msg:  "slippage: Too much SOL required to buy the given amount of tokens.",
		name: "TooMuchSolRequired",
	}
	ErrTooLittleSolReceived = &customErrorDef{
		code: 6003,
		msg:  "slippage: Too little SOL received to sell the given amount of tokens.",
		name: "TooLittleSolReceived",
	}
	ErrMintDoesNotMatchBondingCurve = &customErrorDef{
		code: 6004,
		msg:  "The mint does not match the bonding curve.",
		name: "MintDoesNotMatchBondingCurve",
	}
	ErrBondingCurveComplete = &customErrorDef{
		code: 6005,
		msg:  "The bonding curve has completed and liquidity migrated to raydium.",
		name: "BondingCurveComplete",
	}
	ErrBondingCurveNotComplete = &customErrorDef{
		code: 6006,
		msg:  "The bonding curve has not completed.",
		name: "BondingCurveNotComplete",
	}
	ErrNotInitialized = &customErrorDef{
		code: 6007,
		msg:  "The program is not initialized.",
		name: "NotInitialized",
	}
	ErrWithdrawTooFrequent = &customErrorDef{
		code: 6008,
		msg:  "Withdraw too frequent",
		name: "WithdrawTooFrequent",
	}
	ErrNewSizeShouldBeGreaterThanCurrentSize = &customErrorDef{
		code: 6009,
		msg:  "new_size should be > current_size",
		name: "NewSizeShouldBeGreaterThanCurrentSize",
	}
	ErrAccountTypeNotSupported = &customErrorDef{
		code: 6010,
		msg:  "Account type not supported",
		name: "AccountTypeNotSupported",
	}
	ErrInitialRealTokenReservesShouldBeLessThanTokenTotalSupply = &customErrorDef{
		code: 6011,
		msg:  "initial_real_token_reserves should be less than token_total_supply",
		name: "InitialRealTokenReservesShouldBeLessThanTokenTotalSupply",
	}
	ErrInitialVirtualTokenReservesShouldBeGreaterThanInitialRealTokenReserves = &customErrorDef{
		code: 6012,
		msg:  "initial_virtual_token_reserves should be greater than initial_real_token_reserves",
		name: "InitialVirtualTokenReservesShouldBeGreaterThanInitialRealTokenReserves",
	}
	ErrFeeBasisPointsGreaterThanMaximum = &customErrorDef{
		code: 6013,
		msg:  "fee_basis_points greater than maximum",
		name: "FeeBasisPointsGreaterThanMaximum",
	}
	ErrAllZerosWithdrawAuthority = &customErrorDef{
		code: 6014,
		msg:  "Withdraw authority cannot be set to System Program ID",
		name: "AllZerosWithdrawAuthority",
	}
	ErrPoolMigrationFeeShouldBeLessThanFinalRealSolReserves = &customErrorDef{
		code: 6015,
		msg:  "pool_migration_fee should be less than final_real_sol_reserves",
		name: "PoolMigrationFeeShouldBeLessThanFinalRealSolReserves",
	}
	ErrPoolMigrationFeeShouldBeGreaterThanCreatorFeePlusMaxMigrateFees = &customErrorDef{
		code: 6016,
		msg:  "pool_migration_fee should be greater than creator_fee + MAX_MIGRATE_FEES",
		name: "PoolMigrationFeeShouldBeGreaterThanCreatorFeePlusMaxMigrateFees",
	}
	ErrDisabledWithdraw = &customErrorDef{
		code: 6017,
		msg:  "Migrate instruction is disabled",
		name: "DisabledWithdraw",
	}
	ErrDisabledMigrate = &customErrorDef{
		code: 6018,
		msg:  "Migrate instruction is disabled",
		name: "DisabledMigrate",
	}
	ErrInvalidCreator = &customErrorDef{
		code: 6019,
		msg:  "Invalid creator pubkey",
		name: "InvalidCreator",
	}
	ErrBuyZeroAmount = &customErrorDef{
		code: 6020,
		msg:  "Buy zero amount",
		name: "BuyZeroAmount",
	}
	ErrNotEnoughTokensToBuy = &customErrorDef{
		code: 6021,
		msg:  "Not enough tokens to buy",
		name: "NotEnoughTokensToBuy",
	}
	ErrSellZeroAmount = &customErrorDef{
		code: 6022,
		msg:  "Sell zero amount",
		name: "SellZeroAmount",
	}
	ErrNotEnoughTokensToSell = &customErrorDef{
		code: 6023,
		msg:  "Not enough tokens to sell",
		name: "NotEnoughTokensToSell",
	}
	ErrOverflow = &customErrorDef{
		code: 6024,
		msg:  "Overflow",
		name: "Overflow",
	}
	ErrTruncation = &customErrorDef{
		code: 6025,
		msg:  "Truncation",
		name: "Truncation",
	}
	ErrDivisionByZero = &customErrorDef{
		code: 6026,
		msg:  "Division by zero",
		name: "DivisionByZero",
	}
	ErrNotEnoughRemainingAccounts = &customErrorDef{
		code: 6027,
		msg:  "Not enough remaining accounts",
		name: "NotEnoughRemainingAccounts",
	}
	ErrAllFeeRecipientsShouldBeNonZero = &customErrorDef{
		code: 6028,
		msg:  "All fee recipients should be non-zero",
		name: "AllFeeRecipientsShouldBeNonZero",
	}
	ErrUnsortedNotUniqueFeeRecipients = &customErrorDef{
		code: 6029,
		msg:  "Unsorted or not unique fee recipients",
		name: "UnsortedNotUniqueFeeRecipients",
	}
	ErrCreatorShouldNotBeZero = &customErrorDef{
		code: 6030,
		msg:  "Creator should not be zero",
		name: "CreatorShouldNotBeZero",
	}
	Errors = map[int]CustomError{
		6000: ErrNotAuthorized,
		6001: ErrAlreadyInitialized,
		6002: ErrTooMuchSolRequired,
		6003: ErrTooLittleSolReceived,
		6004: ErrMintDoesNotMatchBondingCurve,
		6005: ErrBondingCurveComplete,
		6006: ErrBondingCurveNotComplete,
		6007: ErrNotInitialized,
		6008: ErrWithdrawTooFrequent,
		6009: ErrNewSizeShouldBeGreaterThanCurrentSize,
		6010: ErrAccountTypeNotSupported,
		6011: ErrInitialRealTokenReservesShouldBeLessThanTokenTotalSupply,
		6012: ErrInitialVirtualTokenReservesShouldBeGreaterThanInitialRealTokenReserves,
		6013: ErrFeeBasisPointsGreaterThanMaximum,
		6014: ErrAllZerosWithdrawAuthority,
		6015: ErrPoolMigrationFeeShouldBeLessThanFinalRealSolReserves,
		6016: ErrPoolMigrationFeeShouldBeGreaterThanCreatorFeePlusMaxMigrateFees,
		6017: ErrDisabledWithdraw,
		6018: ErrDisabledMigrate,
		6019: ErrInvalidCreator,
		6020: ErrBuyZeroAmount,
		6021: ErrNotEnoughTokensToBuy,
		6022: ErrSellZeroAmount,
		6023: ErrNotEnoughTokensToSell,
		6024: ErrOverflow,
		6025: ErrTruncation,
		6026: ErrDivisionByZero,
		6027: ErrNotEnoughRemainingAccounts,
		6028: ErrAllFeeRecipientsShouldBeNonZero,
		6029: ErrUnsortedNotUniqueFeeRecipients,
		6030: ErrCreatorShouldNotBeZero,
	}
)

type CustomError interface {
	Code() int
	Name() string
	Error() string
}

type customErrorDef struct {
	code int
	name string
	msg  string
}

func (e *customErrorDef) Code() int {
	return e.code
}

func (e *customErrorDef) Name() string {
	return e.name
}

func (e *customErrorDef) Error() string {
	return fmt.Sprintf("%s(%d): %s", e.name, e.code, e.msg)
}

func DecodeCustomError(rpcErr error) (err error, ok bool) {
	if errCode, o := decodeErrorCode(rpcErr); o {
		if customErr, o := Errors[errCode]; o {
			err = customErr
			ok = true
			return
		}
	}
	return
}

func decodeErrorCode(rpcErr error) (errorCode int, ok bool) {
	var jErr *ag_jsonrpc.RPCError
	if errors.As(rpcErr, &jErr) && jErr.Data != nil {
		if root, o := jErr.Data.(map[string]interface{}); o {
			if rootErr, o := root["err"].(map[string]interface{}); o {
				if rootErrInstructionError, o := rootErr["InstructionError"]; o {
					if rootErrInstructionErrorItems, o := rootErrInstructionError.([]interface{}); o {
						if len(rootErrInstructionErrorItems) == 2 {
							if v, o := rootErrInstructionErrorItems[1].(map[string]interface{}); o {
								if v2, o := v["Custom"].(json.Number); o {
									if code, err := v2.Int64(); err == nil {
										ok = true
										errorCode = int(code)
									}
								} else if v2, o := v["Custom"].(float64); o {
									ok = true
									errorCode = int(v2)
								}
							}
						}
					}
				}
			}
		}
	}
	return
}
